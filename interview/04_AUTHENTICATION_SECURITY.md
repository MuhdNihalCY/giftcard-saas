# Authentication & Security - Interview Preparation

## Overview

This document covers authentication mechanisms, security implementations, and security best practices in the Gift Card SaaS Platform.

---

## Authentication Architecture

### JWT-Based Authentication

**Why JWT over Sessions?**
- **Stateless:** No server-side session storage needed
- **Scalability:** Works across multiple servers
- **Mobile Support:** Easy to use with mobile apps
- **Performance:** No database lookup for each request
- **Microservices:** Easy to share across services

**Alternatives Considered:**
- **Session Cookies:** Requires Redis/session store, harder to scale
- **OAuth 2.0:** Overkill for this use case
- **API Keys:** Less secure, no expiration

---

## JWT Token System

### Access Token

**Purpose:** Short-lived token for API authentication

**Configuration:**
- **Expiration:** 15 minutes (configurable)
- **Secret:** `JWT_SECRET` environment variable
- **Algorithm:** HS256 (HMAC SHA-256)

**Payload:**
```typescript
{
  userId: string;
  email: string;
  role: UserRole;
}
```

**Usage:**
- Sent in `Authorization: Bearer <token>` header
- Validated on every protected route
- Short expiration reduces risk if compromised

**Code Example:**
```typescript
// Generate access token
const accessToken = jwt.sign(
  { userId: user.id, email: user.email, role: user.role },
  env.JWT_SECRET,
  { expiresIn: '15m' }
);

// Verify access token
const payload = jwt.verify(token, env.JWT_SECRET);
```

---

### Refresh Token

**Purpose:** Long-lived token to obtain new access tokens

**Configuration:**
- **Expiration:** 30 days (configurable)
- **Secret:** `JWT_REFRESH_SECRET` (different from access token secret)
- **Storage:** Database (RefreshToken model)
- **Rotation:** Token rotated on each refresh

**Features:**
- **Device Tracking:** Stores device info (name, type, IP)
- **Revocation:** Can be revoked individually
- **Rotation:** New token issued on each refresh
- **Expiration:** Automatic expiration tracking

**RefreshToken Model:**
```prisma
model RefreshToken {
  id          String   @id
  userId      String
  token       String   @unique
  deviceName  String?
  deviceType  String?  // MOBILE, DESKTOP, TABLET
  userAgent   String?
  ipAddress   String?
  lastUsedAt  DateTime
  expiresAt   DateTime
  revokedAt   DateTime?
}
```

**Refresh Flow:**
1. Client sends refresh token
2. Server verifies token and checks database
3. Server generates new access token
4. Server rotates refresh token (new token issued)
5. Old refresh token marked as revoked
6. Client receives new tokens

**Code Example:**
```typescript
// Refresh token with rotation
async refreshToken(refreshToken: string) {
  // Verify token
  const payload = jwt.verify(refreshToken, env.JWT_REFRESH_SECRET);
  
  // Check database record
  const tokenRecord = await prisma.refreshToken.findUnique({
    where: { id: payload.refreshTokenId },
  });
  
  // Verify not revoked/expired
  if (!tokenRecord || tokenRecord.revokedAt || tokenRecord.expiresAt < new Date()) {
    throw new UnauthorizedError('Invalid refresh token');
  }
  
  // Revoke old token
  await prisma.refreshToken.update({
    where: { id: tokenRecord.id },
    data: { revokedAt: new Date() },
  });
  
  // Generate new tokens
  const newTokens = await this.generateTokens(payload);
  
  return newTokens;
}
```

---

## Token Refresh Flow

### Frontend Implementation

**Automatic Refresh:**
- Axios interceptor catches 401 errors
- Automatically refreshes token
- Retries original request
- Queues concurrent requests during refresh

**Code Example:**
```typescript
// Axios interceptor
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      // Refresh token
      const refreshToken = auth.getRefreshToken();
      const response = await axios.post('/auth/refresh', { refreshToken });
      
      // Update tokens
      auth.setTokens(response.data.accessToken, response.data.refreshToken);
      
      // Retry original request
      originalRequest.headers.Authorization = `Bearer ${response.data.accessToken}`;
      return api(originalRequest);
    }
    return Promise.reject(error);
  }
);
```

---

## Password Security

### Password Hashing

**Algorithm:** bcrypt

**Configuration:**
- **Rounds:** 10 (configurable)
- **Salt:** Automatically generated by bcrypt
- **Storage:** Hash stored, never plain text

**Why bcrypt?**
- **Slow:** Intentionally slow to prevent brute force
- **Salt:** Automatic salt generation
- **Battle-tested:** Widely used and secure
- **Adaptive:** Can increase rounds over time

**Alternatives:**
- **Argon2:** Newer, considered more secure, but less widely adopted
- **PBKDF2:** Older standard, still secure
- **scrypt:** Good alternative, less common

**Code Example:**
```typescript
// Hash password
const passwordHash = await bcrypt.hash(password, 10);

// Verify password
const isValid = await bcrypt.compare(password, user.passwordHash);
```

---

### Account Lockout

**Purpose:** Prevent brute force attacks

**Implementation:**
- **Max Attempts:** 5 failed login attempts
- **Lockout Duration:** 30 minutes
- **Tracking:** `failedLoginAttempts` and `lockedUntil` fields

**Code Example:**
```typescript
if (!isPasswordValid) {
  const failedAttempts = user.failedLoginAttempts + 1;
  
  if (failedAttempts >= 5) {
    // Lock account for 30 minutes
    await prisma.user.update({
      where: { id: user.id },
      data: {
        failedLoginAttempts: failedAttempts,
        lockedUntil: new Date(Date.now() + 30 * 60 * 1000),
      },
    });
    throw new UnauthorizedError('Account locked');
  }
  
  // Increment attempts
  await prisma.user.update({
    where: { id: user.id },
    data: { failedLoginAttempts: failedAttempts },
  });
}
```

---

## Two-Factor Authentication (2FA)

### TOTP Implementation

**Standard:** RFC 6238 (Time-based One-Time Password)

**Library:** speakeasy

**Configuration:**
- **Algorithm:** TOTP
- **Time Step:** 30 seconds
- **Window:** 2 time steps (60 seconds tolerance)
- **Secret Length:** 32 characters (base32)

**Setup Flow:**
1. User requests 2FA setup
2. Server generates TOTP secret
3. Server generates QR code (otpauth:// URL)
4. User scans QR code with authenticator app
5. User verifies with TOTP code
6. Server enables 2FA and stores secret

**Code Example:**
```typescript
// Generate secret
const secret = speakeasy.generateSecret({
  name: `Gift Card SaaS (${userId})`,
  length: 32,
});

// Generate QR code
const otpAuthUrl = speakeasy.otpauthURL({
  secret: secret.base32,
  label: email,
  issuer: 'Gift Card SaaS',
  encoding: 'base32',
});

const qrCodeUrl = await QRCode.toDataURL(otpAuthUrl);

// Verify token
const verified = speakeasy.totp.verify({
  secret: user.twoFactorSecret,
  encoding: 'base32',
  token: providedToken,
  window: 2, // 60 seconds tolerance
});
```

---

### Backup Codes

**Purpose:** Recovery mechanism if authenticator app lost

**Implementation:**
- **Count:** 10 backup codes
- **Length:** 8 characters
- **Storage:** Hashed with bcrypt (same as passwords)
- **Usage:** Single-use, removed after use

**Code Example:**
```typescript
// Generate backup codes
generateBackupCodes(): string[] {
  const codes: string[] = [];
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  
  for (let i = 0; i < 10; i++) {
    let code = '';
    for (let j = 0; j < 8; j++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    codes.push(code);
  }
  return codes;
}

// Hash and store
const hashedCodes = await Promise.all(
  codes.map(code => bcrypt.hash(code, 10))
);

// Verify and consume
const isMatch = await bcrypt.compare(providedCode, hashedCode);
if (isMatch) {
  // Remove used code from array
  backupCodes.splice(index, 1);
}
```

---

## CSRF Protection

### Implementation

**Library:** csrf

**Mechanism:**
- **Token Generation:** Server generates CSRF token per session
- **Token Storage:** Session (`req.session.csrfSecret`)
- **Token Delivery:** Cookie (`XSRF-TOKEN`) and header (`X-CSRF-Token`)
- **Token Verification:** Verified on state-changing requests (POST, PUT, PATCH, DELETE)

**Why CSRF Protection?**
- **Prevents:** Cross-site request forgery attacks
- **Required:** For cookie-based sessions
- **JWT Alternative:** JWT in headers provides some protection, but CSRF adds defense in depth

**Code Example:**
```typescript
// Generate CSRF token
export const generateCSRFToken = (req: Request, res: Response) => {
  if (!req.session.csrfSecret) {
    req.session.csrfSecret = tokens.secretSync();
  }
  
  const token = tokens.create(req.session.csrfSecret);
  
  // Set cookie
  res.cookie('XSRF-TOKEN', token, {
    httpOnly: false, // Accessible to JavaScript
    secure: isProduction,
    sameSite: isProduction ? 'none' : 'lax',
  });
  
  // Set header
  res.setHeader('X-CSRF-Token', token);
};

// Verify CSRF token
export const verifyCSRF = (req: Request, res: Response, next: NextFunction) => {
  const secret = req.session?.csrfSecret;
  const token = req.headers['x-csrf-token'] || req.body._csrf;
  
  if (!tokens.verify(secret, token)) {
    throw new UnauthorizedError('Invalid CSRF token');
  }
  
  next();
};
```

**Frontend Integration:**
```typescript
// Axios interceptor adds CSRF token
api.interceptors.request.use((config) => {
  if (['post', 'put', 'patch', 'delete'].includes(config.method)) {
    const csrfToken = getCSRFToken(); // From cookie
    config.headers['X-CSRF-Token'] = csrfToken;
  }
  return config;
});
```

---

## Rate Limiting

### Implementation

**Library:** express-rate-limit

**Strategies:**

1. **API Rate Limiter**
   - **Window:** 15 minutes
   - **Max Requests:** 5000 per window (~333/minute)
   - **Scope:** All API endpoints

2. **Auth Rate Limiter**
   - **Window:** 15 minutes
   - **Max Requests:** 100 attempts
   - **Scope:** Login, register, password reset

3. **Payment Rate Limiter**
   - **Window:** 1 minute
   - **Max Requests:** 100 payments
   - **Scope:** Payment endpoints

**Code Example:**
```typescript
export const apiRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5000,
  message: {
    success: false,
    error: {
      code: 'TOO_MANY_REQUESTS',
      message: 'Too many requests, please try again later.',
    },
  },
});

export const authRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: {
    success: false,
    error: {
      code: 'TOO_MANY_REQUESTS',
      message: 'Too many authentication attempts, please try again later.',
    },
  },
});
```

**Why Rate Limiting?**
- **Prevents:** DDoS attacks, brute force attacks
- **Protects:** API endpoints from abuse
- **Fair Usage:** Ensures fair resource usage

---

## Security Headers

### Helmet Middleware

**Library:** helmet

**Headers Set:**
- **Content-Security-Policy:** Prevents XSS attacks
- **X-DNS-Prefetch-Control:** Controls DNS prefetching
- **X-Frame-Options:** Prevents clickjacking
- **X-Content-Type-Options:** Prevents MIME sniffing
- **Referrer-Policy:** Controls referrer information
- **Strict-Transport-Security:** Forces HTTPS

**Code Example:**
```typescript
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", 'data:', 'https:'],
    },
  },
}));
```

---

## Input Validation

### Zod Schema Validation

**Library:** Zod

**Purpose:** Validate and sanitize input data

**Benefits:**
- **Type Safety:** Generates TypeScript types
- **Runtime Validation:** Validates at runtime
- **Error Messages:** Clear validation errors
- **Sanitization:** Can sanitize input

**Code Example:**
```typescript
import { z } from 'zod';

const createGiftCardSchema = z.object({
  value: z.number().positive().max(10000),
  currency: z.string().length(3),
  expiryDate: z.date().optional(),
  recipientEmail: z.string().email().optional(),
});

// Validate
const validatedData = createGiftCardSchema.parse(req.body);
```

**Middleware:**
```typescript
export const validate = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      req.body = schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError('Validation failed', error.errors);
      }
      next(error);
    }
  };
};
```

---

## SQL Injection Prevention

### Prisma ORM

**How It Prevents SQL Injection:**
- **Parameterized Queries:** All queries use parameters
- **Type Safety:** TypeScript prevents string concatenation
- **Query Builder:** No raw SQL strings

**Code Example:**
```typescript
// Safe - Prisma handles parameterization
const user = await prisma.user.findUnique({
  where: { email: userEmail }, // Parameterized
});

// Unsafe - Never do this (Prisma prevents it anyway)
// const query = `SELECT * FROM users WHERE email = '${email}'`;
```

---

## XSS Prevention

### Strategies

1. **Content Security Policy (CSP):** Via Helmet
2. **Input Sanitization:** Zod validation
3. **Output Encoding:** React automatically escapes
4. **HttpOnly Cookies:** Prevents JavaScript access

**React Protection:**
- React automatically escapes content in JSX
- Prevents XSS by default
- Use `dangerouslySetInnerHTML` only when necessary (with sanitization)

---

## Session Management

### Redis Session Store

**Library:** connect-redis

**Configuration:**
- **Store:** Redis (if available)
- **Fallback:** Memory store (development)
- **Cookie:** Secure, httpOnly, sameSite

**Code Example:**
```typescript
import session from 'express-session';
import { RedisStore } from 'connect-redis';

app.use(session({
  store: redisClient ? new RedisStore({ client: redisClient }) : undefined,
  secret: env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: isProduction,
    httpOnly: true,
    sameSite: isProduction ? 'none' : 'lax',
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
  },
}));
```

---

## Audit Logging

### Implementation

**Purpose:** Track all security-relevant actions

**Logged Events:**
- Login attempts (success/failure)
- Password changes
- 2FA enable/disable
- Payment creation
- Gift card creation/deletion
- Admin actions

**AuditLog Model:**
```prisma
model AuditLog {
  id           String   @id
  userId       String?
  userEmail    String?
  action       String   // LOGIN, PAYMENT_CREATED, etc.
  resourceType String   // User, Payment, GiftCard
  resourceId   String?
  ipAddress    String?
  userAgent    String?
  metadata     Json?
  createdAt    DateTime
}
```

**Code Example:**
```typescript
await prisma.auditLog.create({
  data: {
    userId: user.id,
    userEmail: user.email,
    action: 'LOGIN',
    resourceType: 'User',
    resourceId: user.id,
    ipAddress: req.ip,
    userAgent: req.headers['user-agent'],
  },
});
```

---

## Fraud Prevention

### Device Fingerprinting

**Purpose:** Track devices for fraud detection

**Data Collected:**
- IP address
- User agent
- Device type
- Device name

**Usage:**
- Stored with payments
- Used for fraud detection
- Tracked in RefreshToken model

---

### Fraud Blacklist

**Purpose:** Block known fraudulent entities

**Types:**
- Email addresses
- IP addresses
- Phone numbers
- Payment methods
- User IDs

**Implementation:**
```prisma
model FraudBlacklist {
  id         String            @id
  type       BlacklistType     // EMAIL, IP, PHONE, etc.
  value      String
  severity   BlacklistSeverity // LOW, MEDIUM, HIGH, CRITICAL
  autoBlock  Boolean
  expiresAt  DateTime?
}
```

**Check Before Actions:**
- User registration
- Payment processing
- Login attempts

---

## Interview Questions & Answers

### Q: Why JWT over sessions?

**A:** JWT chosen because:
1. **Stateless:** No server-side storage needed
2. **Scalability:** Works across multiple servers
3. **Mobile Support:** Easy with mobile apps
4. **Performance:** No database lookup per request
5. **Microservices:** Easy to share tokens

Trade-off: Harder to revoke tokens (need refresh token rotation)

### Q: Explain your refresh token implementation.

**A:** Refresh token implementation:
1. **Storage:** Database (RefreshToken model)
2. **Rotation:** New token on each refresh
3. **Device Tracking:** Stores device info
4. **Revocation:** Can revoke individual tokens
5. **Expiration:** 30 days, tracked in database

Benefits:
- Can revoke tokens
- Track devices
- Detect suspicious activity
- Better security than stateless refresh tokens

### Q: How does 2FA work?

**A:** TOTP-based 2FA:
1. **Setup:** Generate secret, create QR code
2. **Storage:** Secret stored encrypted in database
3. **Verification:** Verify TOTP code (30-second window, 2-step tolerance)
4. **Backup Codes:** 10 single-use codes, hashed with bcrypt

Library: speakeasy (RFC 6238 compliant)

### Q: How do you prevent SQL injection?

**A:** SQL injection prevention:
1. **Prisma ORM:** All queries parameterized
2. **Type Safety:** TypeScript prevents string concatenation
3. **No Raw SQL:** Prisma query builder only
4. **Input Validation:** Zod validates all input

Prisma automatically parameterizes all queries, preventing SQL injection.

### Q: Explain CSRF protection.

**A:** CSRF protection:
1. **Token Generation:** Server generates per session
2. **Token Storage:** Session (`csrfSecret`)
3. **Token Delivery:** Cookie and header
4. **Verification:** Verified on state-changing requests
5. **JWT Alternative:** JWT in headers provides some protection

Why needed: Prevents cross-site request forgery attacks

### Q: How does rate limiting work?

**A:** Rate limiting:
1. **API:** 5000 requests per 15 minutes
2. **Auth:** 100 attempts per 15 minutes
3. **Payment:** 100 payments per minute
4. **Implementation:** express-rate-limit middleware

Prevents: DDoS, brute force attacks, API abuse

---

## Key Takeaways

1. **JWT Authentication** with access/refresh tokens
2. **Token Rotation** on refresh for security
3. **Password Hashing** with bcrypt (10 rounds)
4. **Account Lockout** after 5 failed attempts
5. **2FA (TOTP)** with backup codes
6. **CSRF Protection** via tokens
7. **Rate Limiting** on all endpoints
8. **Security Headers** via Helmet
9. **Input Validation** with Zod
10. **Audit Logging** for security events

---

*See other documents for payment security and fraud prevention details.*
